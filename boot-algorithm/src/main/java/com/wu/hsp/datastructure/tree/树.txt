术语：
1)节点
2)根节点
3)父节点
4)子节点
5)叶子节点(没有子节点的节点)
6)节点的权(节点的值)
7)路径(从root节点到该节点的路线)
8)层
9)子树
10)树的高度(最大层数)

二叉树：
    1、每个节点最多只能有两个子节点的一种形式称为二叉树
    2、二叉树的子节点分为左节点和右节点
    3、二叉树的所有叶子节点都在最后一层，并且节点数的总数=2^n-1,n为层数 ，则为满二叉树
    4、二叉树的所有叶子节点都在最后一层或者倒数第二层，而且最后一层的叶子节点在左边连续，倒数第二层的叶子节点在右边连续，则为完全二叉树

遍历：主要看父节点的输出顺序，
    1、前序遍历：先输出父节点，在遍历左子树和右子树
        1.1、先输出当前节点(初始的时候是root节点)
        1.2、如果左子树不为空，则递归继续前序遍历
        1.3、如果右子树不为空，则递归继续前序遍历

    2、中序遍历：先遍历左子树，在输出父节点，在遍历右子树
        2.1、如果当前节点的左子节点不为空，则递归中序遍历
        2.2、输出当前节点
        2.3、如果当前节点的右子节点不为空，则递归中序遍历

    3、后序遍历：先遍历左子树，在遍历右子树，最后输出父节点
        3.1、如果当前节点的左子节点不为空，则递归后序遍历
        3.2、如果当前节点的右子节点不为空，则递归后序遍历
        3.3、输出当前节点

顺序存储二叉树
    从数据存储来看，数组存储方式和树的存储方式可以互换，即数组可以转换为树，树也可以转换为数组
              1
        2            3
    4       5    6       7             转换的数组是[1,2,3,4,5,6,7]

    顺序存储二叉树的特点
        1)顺序存储通常只考虑完全二叉树
        2)第n个元素的左子节点为2*n+1
        3)第n个元素的右子节点为2*n+2
        4)第n个元素的父节点为(n-1)/2
        5)n:表示二叉树中的第几个元素(按0开始编号)


线索化二叉树
    1)、n个节点的二叉链表中含有n+1【公式:2n-(n-1)=n+1】个空指针域，利用二叉链表中的空指针域，存放指向该节点的某种遍历次序下
    的前驱和后继节点的指针(这种附件的指针称为“线索”)
    2)、这种加上了线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树(Threaded BinaryTree)
        根据线索的性质不同，可分为前序线索二叉树  中序线索二叉树  后序线索二叉树
    3)、一个节点的前一个节点，称为 前驱节点
    4)、一个节点的后一个节点，称为 后继节点



堆排序<升序使用大顶堆  降序使用小顶堆>
    堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，他的最坏，最好，平均时间复杂度均为O(nlogn)，它不是稳定排序
    堆具有以下性质的完全二叉树:
        每个节点的值都大于或等于其左右孩子节点的值，称为 大顶堆 (没有要求左右孩子节点的值的大小关系)
        每个节点的值都小于或等于其左右孩子节点的值，称为小顶堆


    大顶堆排序思想 ||大顶堆特点 arr[i] >= arr[2*i+1] && arr[i] >= arr[2*i+2]  i对应第几个节点，i从0开始编号
        1、将待排序序列构造成大顶堆
        2、此时，整个序列的最大值就是堆顶的根节点
        3、将其与末尾元素进行交换，此时末尾就是最大值
        4、然后将剩余n-1个元素重新构造一个对，这样会得到n个元素的次小值。如此反复执行，变能得到一个有序序列了

哈弗曼树
    1)给定 n 个权重作为n个 叶子节点，构造一颗二叉树，若该树的 带权路径长度(wpl) 达到最小值，称这样的二叉树为 最优二叉树，也称为 哈佛曼树(HuffmanTree)
    2)哈弗曼树 是带权路径长度最短 的树，权值较大的节点离根较近

    重要概念
    1)路径和路径长度
        在一颗树中，从一个节点往下可以达到的孩子或孙子节点直接的通路，无痕微路径
        通路中分支的数目称为路径长度。若规定根节点的层数为1，则从根节点到第L层节点的路径长度为L-1

    2)节点的权 及 带权路径长度
        若将数中节点赋给一个有着某种含义的数值，则这个数值称为该节点的权
        节点的带权路径长度为：从根节点到该节点直接的路径长度域该节点的权的乘积

    3)树的带权路径长度(WPL)
        规定所有的 叶子节点 的带权路径长度之和 记为WPL(weighted path length) 权值越大的节点离根节点越近的二叉树才是最优二叉树

    4）WPL最小的就是哈夫曼树

哈夫曼编码


二叉排序树


平衡二叉树(AVL)
    前提是一颗二叉排序树，但是相对于二叉排序树，特殊情况下可能变成为链表形式（比如 左子树都为空）
    特点：
        它是一颗空树 或者 它的的左右两个子树的高度差的绝对值不超过1 并且左右两个子树都是一颗平衡二叉树
        平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树、Treep、伸展树 。。。

    树的高度
    左子树的高度
    右子树的高度

    左旋转
    先右旋转->后左旋转
    右旋转
    先左旋转->后右旋转

红黑树
    1、每个节点或者是黑色 或者是红色
    2、根节点是黑色的
    3、每一个叶子节点(最后的空节点)是黑色的
    4、如果一个节点第红色的，那么他的孩子节点都是黑色的
    5、从任意一个节点到叶子节点，经过的黑色节点是一样的


二叉树的缺点
1、二叉树 需要加载到内存 ，如果节点少，没有什么问题，当二叉树的节点很多，就会存在问题
    1.1)、在构建二叉树时，需要多次进行I/O操作(大量数据存储在数据库或文件中)，节点多，构建二叉树时，速度有影响
    1.2)、节点多，或造成二叉树高度很大，会降低操作速度

多叉树【multiWay tree】
    允许每个节点可以有更多的子节点，就是多叉树



2-3树 最简单的B树，也要满足大小顺序
    1、2-3树的所有叶子节点都在同一层(只要是B树都满足这个条件)
    2、有两个子节点的节点 叫二节点，二节点 要么没有子节点 要么有两个子节点
    3、有三个子节点的节点 叫三节点，三节点 要么没有子节点 要么有三个子节点
    4、2-3树有二节点和三节点构成的树 每个节点最多有两个值
    5、不满足时，要拆分，先向上层拆，然后向本层拆

    添加的时候，绝对不会添加到空节点(除第一个节点)


B树(B-Tree) B即Balanced 平衡树
    1、B树通过重新组织节点，降低树的高度
    2、文件系统及数据库系统的设计者 利用了磁盘预读原理，将一个节点的大小设置为等于一个页(通常为4k)，这样 每个节点值需要一次I/O就可以完全加载到内存

    B树说明：
        1)、B树的阶:节点的最多子节点个数  比如2-3树的阶是3 ，2-3-4树的阶是4
        2)、B-树的搜索，从根节点开始，对节点内的关键字(有序)序列进行二分查找，如果命中则结束，否则进行查询关键字所属范围儿子节点里，重复，知道所对应的儿子指针为空 或者 已经是叶子节点
        3)、关键字集合 分布在整颗树中，即叶子节点和非叶子节点都存放数据
        4)、搜索有可能在非叶子节点结束
        5)、其搜索性能等价于在关键字全集内做一次二分查找

    B+树说明：
        1)、B+树的搜索和和B树基本相同 区别是B+树只有达到叶子节点才命中 其搜索性能等价于在关键字全集内做一次二分查找
        2)、所有 关键字都出现在叶子节点的链表中(即数据只能在叶子节点中[也叫稠密索引]) 且链表中的关键字(数据)也是有序的
        3)、不可能在非叶子节点命中
        4)、非叶子节点相当于是叶子节点的索引【稀疏索引】，叶子节点相遇是存储(关键字)数据的数据层
        5)、更适合文件索引系统 (比如mysql)
        6)、B树和B+树个有自己的应用场景，不能说B+树完全比B树好，反正也然
